package oauth

import (
	"crypto/ecdsa"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"fmt"

	"github.com/fxamacker/cbor/v2"
)

func Authorize() {

}

type GrantType string

const (
	GrantTypeAuthorizationCode GrantType = "authorization_code"
	GrantTypeRefreshToken      GrantType = "refresh_token"
)

type ClientAssertionType string

const (
	ClientAssertionTypeAppleAppAttest = "urn:ietf:params:oauth:client-assertion-type:apple-appattest"
)

type SignedTokenRequest struct {
	Scope     string    `json:"scope,omitempty"`
	GrantType GrantType `json:"grant_type"`

	// one-of
	AuthorizationCodeTokenRequest
	RefreshTokenTokenRequest
}
type TokenRequest struct {
	ClientId string `json:"client_id"`

	// Only supported value is CLientAssertionTypeAppleAppAttest
	ClientAssertionType ClientAssertionType `json:"client_assertion_type"`

	// Generated by calling DCAppAttestService.shared.generateAssertion(client_id, SHA256(restOfTheTokenRequest)) and base64urlencode it
	ClientAssertion string `json:"client_assertion"`

	SignedTokenRequest
}

type AuthorizationCodeTokenRequest struct {
	Code         string `json:"code"`
	RedirectUri  string `json:"redirect_uri"`
	CodeVerifier string `json:"code_verifier"`
}

type RefreshTokenTokenRequest struct {
	RefreshToken string `json:"refresh_token"`
}

func (RefreshTokenTokenRequest) GrantType() GrantType {
	return GrantTypeRefreshToken
}

type TokenType string

const (
	TokenTypeDPoP TokenType = "DPoP"
)

// MUST set Cache-Control: no-store
type TokenResponse struct {
	AccessToken  string    `json:"access_token"`
	TokenType    TokenType `json:"token_type"`
	ExpiresIn    *int64    `json:"expires_in,omitempty"`
	Scope        string    `json:"scope,omitempty"`
	RefreshToken string    `json:"refresh_token,omitempty"`
}

type AuthenticatorData struct {
	RPIDHash    [32]byte
	UnusedFlags byte
	Count       uint32
}

type ClientAssertion struct {
	Signature         []byte `json:"signature"`
	AuthenticatorData []byte `json:"authenticatorData"`
}

func getPublicKey(clientId string) (*ecdsa.PublicKey, error) {
	return nil, nil
}

func GetToken(request *TokenRequest) (*TokenResponse, error) {
	if request.ClientAssertionType != ClientAssertionTypeAppleAppAttest {
		return nil, fmt.Errorf("Unsupported assertion type: %s", request.ClientAssertionType)
	}

	clientAssertionBytes, err := base64.RawURLEncoding.DecodeString(request.ClientAssertion)
	if err != nil {
		return nil, fmt.Errorf("invalid client_assertion: %s", err)
	}

	var clientAssertion ClientAssertion

	if err := cbor.Unmarshal(clientAssertionBytes, &clientAssertion); err != nil {
		return nil, fmt.Errorf("invalid client_assertion: %s", err)
	}

	// What to do with refresh token is unknown
	switch request.GrantType {
	case GrantTypeRefreshToken:
		return nil, fmt.Errorf("unsupported grant_type: %s", request.GrantType)
	case GrantTypeAuthorizationCode:

		// TODO(arianvp): Is just signing `code` enough?
		clientDataHash := sha256.Sum256([]byte(request.Code))

		nonce := sha256.Sum256(append(clientAssertion.AuthenticatorData, clientDataHash[:]...))

		publicKey, err := getPublicKey(request.ClientId)
		if err != nil {
			return nil, fmt.Errorf("client_id does not exist: %s", err)
		}

		if !ecdsa.VerifyASN1(publicKey, nonce[:], clientAssertion.Signature) {
			return nil, errors.New("ecdsa: Invalid signature")
		}

		return nil, nil
	}
}
